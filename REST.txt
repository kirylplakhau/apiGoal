			**** REST ****
-  архитектурный стиль взаимодействия компонентов распределённого приложения в сети. Другими словами, REST — это набор правил о том, как программисту 
организовать написание кода серверного приложения, чтобы все системы легко обменивались данными и приложение можно было масштабировать.
REST представляет собой согласованный набор ограничений, учитываемых при проектировании распределённой гипермедиа-системы. В определённых 
случаях (интернет-магазины, поисковые системы, прочие системы, основанные на данных) это приводит к повышению производительности и
упрощению архитектуры. В широком смысле  компоненты в REST взаимодействуют наподобие взаимодействия клиентов и серверов во Всемирной паутине. REST является 
альтернативой RPC.
В сети Интернет вызов удалённой процедуры может представлять собой обычный HTTP-запрос (обычно GET или POST; такой запрос называют «REST-запрос»), 
а необходимые данные передаются в качестве параметров запроса. 
Для веб-служб, построенных с учётом REST (то есть не нарушающих накладываемых им ограничений), применяют термин «RESTful».
В отличие от веб-сервисов (веб-служб) на основе SOAP, не существует «официального» стандарта для RESTful веб-API. Дело в том, что REST является 
архитектурным стилем, в то время как SOAP является протоколом. Несмотря на то, что REST не является стандартом сам по себе, большинство 
RESTful-реализаций используют такие стандарты, как HTTP, URL, JSON и, реже, XML.

	** Свойства Архитектуры REST **
Свойства архитектуры, которые зависят от ограничений, наложенных на REST-системы:

* Производительность — взаимодействие компонентов системы может являться доминирующим фактором производительности и эффективности сети с точки зрения 
пользователя;
* Масштабируемость для обеспечения большого числа компонентов и взаимодействий компонентов.
	Рой Филдинг — один из главных авторов спецификации протокола HTTP, описывает влияние архитектуры REST на масштабируемость следующим образом:

* Простота унифицированного интерфейса;
* Открытость компонентов к возможным изменениям для удовлетворения изменяющихся потребностей (даже при работающем приложении);
* Прозрачность связей между компонентами системы для сервисных служб;
* Переносимость компонентов системы путем перемещения программного кода вместе с данными;
* Надёжность, выражающаяся в устойчивости к отказам на уровне системы при наличии отказов отдельных компонентов, соединений или данных.

	** Требования к архитектуре REST **
1. Модель клиент-сервер. Первым ограничением, применимым к гибридной модели, является приведение архитектуры к модели клиент-сервер. Разграничение 
потребностей является принципом, лежащим в основе данного накладываемого ограничения. Отделение потребности интерфейса клиента от потребностей сервера, 
хранящего данные, повышает переносимость кода клиентского интерфейса на другие платформы, а упрощение серверной части улучшает масштабируемость. 
Наибольшее же влияние на всемирную паутину, пожалуй, имеет само разграничение, которое позволяет отдельным частям развиваться независимо друг от друга, 
поддерживая потребности в развитии интернета со стороны различных организаций.
2. Отсутствие состояния. Протокол взаимодействия между клиентом и сервером требует соблюдения следующего условия: в период между запросами клиента никакая 
информация о состоянии клиента на сервере не хранится (Stateless protocol или «протокол без сохранения состояния»). Все запросы от клиента должны быть 
составлены так, чтобы сервер получил всю необходимую информацию для выполнения запроса. Состояние сессии при этом сохраняется на стороне клиента. 
Информация о состоянии сессии может быть передана сервером какому-либо другому сервису (например, в службу базы данных) для поддержания устойчивого 
состояния, например, на период установления аутентификации. Клиент инициирует отправку запросов, когда он готов (возникает необходимость) перейти в новое 
состояние.
Во время обработки клиентских запросов считается, что клиент находится в переходном состоянии. Каждое отдельное состояние приложения представлено связями, 
которые могут быть задействованы при следующем обращении клиента.
3. Кэширование. Как и во Всемирной паутине, клиенты, а также промежуточные узлы, могут выполнять кэширование ответов сервера. Ответы сервера, в свою 
очередь, должны иметь явное или неявное обозначение как кэшируемые или некэшируемые с целью предотвращения получения клиентами устаревших или неверных 
данных в ответ на последующие запросы. Правильное использование кэширования способно частично или полностью устранить некоторые клиент-серверные 
взаимодействия, ещё больше повышая производительность и масштабируемость системы.
4. Единообразие интерфейса. Наличие унифицированного интерфейса является фундаментальным требованием дизайна REST-сервисов[3]. Унифицированные интерфейсы 
позволяют каждому из сервисов развиваться независимо.
К унифицированным интерфейсам предъявляются следующие четыре ограничительных условия:
* Идентификация ресурсов. Все ресурсы идентифицируются в запросах, например, с использованием URI в интернет-системах. Ресурсы концептуально отделены от 
представлений, которые возвращаются клиентам. Например, сервер может отсылать данные из базы данных в виде HTML, XML или JSON, ни один из которых не 
является типом хранения внутри сервера.
* Манипуляция ресурсами через представление. Если клиент хранит представление ресурса, включая метаданные — он обладает достаточной информацией для 
модификации или удаления ресурса.
* «Самоописываемые» сообщения. Каждое сообщение содержит достаточно информации, чтобы понять, каким образом его обрабатывать. К примеру, обработчик 
сообщения (parser), необходимый для извлечения данных, может быть указан в списке MIME-типов.
* Гипермедиа как средство изменения состояния приложения (HATEOAS). Клиенты изменяют состояние системы только через действия, которые динамически 
определены в гипермедиа на сервере (к примеру, гиперссылки в гипертексте). Исключая простые точки входа в приложение, клиент не может предположить, 
что доступна какая-то операция над каким-то ресурсом, если не получил информацию об этом в предыдущих запросах к серверу. Не существует универсального 
формата для предоставления ссылок между ресурсами, Web Linking (RFC 5988 -> RFC 8288) и JSON Hypermedia API Language являются двумя популярными форматами 
предоставления ссылок в REST HYPERMEDIA сервисах.
5. Слои. Клиент обычно не способен точно определить, взаимодействует он напрямую с сервером или же с промежуточным узлом, в связи с иерархической 
структурой сетей (подразумевая, что такая структура образует слои). Применение промежуточных серверов способно повысить масштабируемость за счёт 
балансировки нагрузки и распределённого кэширования. Промежуточные узлы также могут подчиняться политике безопасности с целью обеспечения 
конфиденциальности информации.
6. Код по требованию (необязательное ограничение). REST может позволить расширить функциональность клиента за счёт загрузки кода с сервера в виде апплетов 
или сценариев. Филдинг утверждает, что дополнительное ограничение позволяет проектировать архитектуру, поддерживающую желаемую функциональность в общем 
случае, но, возможно, за исключением некоторых контекстов.

		*** Преимущества ***
* Надёжность (за счёт отсутствия необходимости сохранять информацию о состоянии клиента, которая может быть утеряна);
* Производительность (за счёт использования кэша);
* Масштабируемость;
* Прозрачность системы взаимодействия (особенно необходимая для приложений обслуживания сети);
* Простота интерфейсов;
* Портативность компонентов;
* Лёгкость внесения изменений;
* Способность эволюционировать, приспосабливаясь к новым требованиям (на примере Всемирной паутины).

			**** HTTP и RESTful веб-сервисы ****
Ресурс

Ресурс — это ключевая абстракция, на которой концентрируется протокол HTTP. Ресурс — это все, что вы хотите показать внешнему миру через ваше приложение. 
Например, если мы пишем приложение для управления задачами, экземпляры ресурсов будут следующие:

* Конкретный пользователь
* Конкретная задача
* Список задач

URI ресурса

Когда вы разрабатываете RESTful сервисы, вы должны сосредоточить свое внимание на ресурсах приложения. Способ, которым мы идентифицируем ресурс для 
предоставления, состоит в том, чтобы назначить ему URI — универсальный идентификатор ресурса. Например:

* Создать пользователя: POST /users
* Удалить пользователя: DELETE /users/1
* Получить всех пользователей: GET /users
* Получить одного пользователя: GET /users/1

REST и Ресурсы

Важно отметить, что с REST вам нужно думать о приложении с точки зрения ресурсов:
Определите, какие ресурсы вы хотите открыть для внешнего мира
Используйте глаголы, уже определенные протоколом HTTP, для выполнения операций с этими ресурсами.

Вот как обычно реализуется служба REST:

* Формат обмена данными: здесь нет никаких ограничений. JSON — очень популярный формат, хотя можно использовать и другие, такие как XML
* Транспорт: всегда HTTP. REST полностью построен на основе HTTP.
* Определение сервиса: не существует стандарта для этого, а REST является гибким. Это может быть недостатком в некоторых сценариях, поскольку потребляющему 
приложению может быть необходимо понимать форматы запросов и ответов. Однако широко используются такие языки определения веб-приложений, как 
WADL (Web Application Definition Language) и Swagger.

Компоненты HTTP

HTTP определяет следующую структуру запроса:

* строка запроса (request line) — определяет тип сообщения
* заголовки запроса (header fields) — характеризуют тело сообщения, параметры передачи и прочие сведения
* тело сообщения (body) — необязательное

HTTP определяет следующую структуру ответного сообщения (response):

* строка состояния (status line), включающая код состояния и сообщение о причине
* поля заголовка ответа (header fields)
* дополнительное тело сообщения (body)

Методы HTTP-запроса

Метод, используемый в HTTP-запросе, указывает, какое действие вы хотите выполнить с этим запросом. Важные примеры:
* GET: получить подробную информацию о ресурсе
* POST: создать новый ресурс
* PUT: обновить существующий ресурс
* DELETE: Удалить ресурс

Код статуса ответа HTTP
Код состояния всегда присутствует в ответе HTTP.